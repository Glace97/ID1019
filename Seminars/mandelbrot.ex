defmodule Cmplx do

  #return complex number with real value r and imaginary nr i
  def new(r, i) do
    {r, i}
  end

  #add two complex nrs
  def add(a, b) do
    {r1, i1} = a
    {r2, i2} = b
    {r1+r2, i1+i2}
  end

  #square a complex nr
  # (a + bi)^2 = a^2 + 2abi + (bi)^2
  def sqr({r,i}) do
    re = r*r + (-1*i*i) # (bi)^2 = i^2 * b^2 = -1 * b^2
    im = 2*r*i
    {re, im}
  end

  #absolute value (length) complex nr
  def abs({r,i}) do
    :math.sqrt(r*r + i*i)
  end
end

defmodule Brot do

  #given complex number and maximum number of iterations
  #returns value i at which |zi| >2 (out of bound) or return within bound number
  def mandelbrot(c, m) do
    z = Cmplx.new(0, 0)
    i = 0
    test(i, z, c, m)
  end

  #return iterationvalue

  #if we are still within mandelbrotset, i will iterate up until m
  #with little to no variation, still within set
  def test(m, _, _, m) do 0 end
  def test(i, z, c, m) do
    #calculate absolute value
    abs = Cmplx.abs(z)

    #if absolutevalue of our latest sum < 2, still within set
     if abs <= 2 do
        z1 = Cmplx.add(Cmplx.sqr(z), c)   #z + c = new z
        test(i+1, z1, c, m)
      else
        #no longer within mandelbrot set
        i
      end
  end

end



#code for printing
defmodule PPM do

  # write(name, image) The image is a list of rows, each row a list of
  # tuples {R,G,B}. The RGB values are 0-255.

  def write(name, image) do
    height = length(image)
    width = length(List.first(image))
    {:ok, fd} = File.open(name, [:write])
    IO.puts(fd, "P6")
    IO.puts(fd, "#generated by ppm.ex")
    IO.puts(fd, "#{width} #{height}")
    IO.puts(fd, "255")
    rows(image, fd)
    File.close(fd)
  end

  defp rows(rows, fd) do
    Enum.each(rows, fn(r) ->
      colors = row(r)
      IO.write(fd, colors)
    end)
  end

  defp row(row) do
    List.foldr(row, [], fn({:rgb, r, g, b}, a) ->
      [r, g, b | a]
    end)
  end

end


#do conversion of RGB values, depth of point d, max depth = m
defmodule Colors do

  #given depth on a scale 0-max, returns a color
  def convert(depth, max) do
    #five section divides range 0 to m

    #fraction f
    f = depth/max
    #floating point 0 - 4
    a = f*4
    #truncate a
    x = trunc(a)
    y = trunc(255*(a-x))

    case x do
      #shades of red
      0 ->
        {:rgb, y, 0, 0}
      # red -> yellow
      1 ->
        {:rgb, 255, y, 0}
      #green -> yellow
      2 ->
        {:rgb, 255-y, 255, 0}
      #green to cyan
      3 ->
        {:rgb, 0, 255, y}
      #blue to -> cyan
      4 ->
        {:rgb, 0, 255-y, 255}
    end
  end
end


defmodule Mandel do

  #generate image of size width by height.
  # x+yi corresponds to upper left corner in image
  # k is offset, 1 step right -> (x+1k) + yi, one step down (next row) -> x + (y-k)i
  def mandelbrot(w, h, x, y, k, depth) do
    #given position, return complex nr for witch depth of is computed
    trans = fn(w, h) ->
    Cmplx.new(x + k * (w - 1), y - k * (h - 1))
    end
   rows(w, h, trans, depth, [])
  end

  #returns list of rows, each row is a list of colors.
  #each item in a row corresponds to a pixel

  def rows(_, 0, _, _, rows) do rows end #entire height checked
  def rows(w, h, trans, max, rows) do
    row = row(w, h, trans, max, [])  #get row for this height
    rows(w, h-1, trans, max, [row|rows])
  end

  def row(0,_h ,_tr ,_max, row) do row end #entire row checked
  def row(w, h, tr_func, max, row) do
    c = tr_func.(w, h)
    #returns #recursions for this complex nr
    recur_depth = Brot.mandelbrot(c, max)
    #get color given #recur for this complex nr
    color = Colors.convert(recur_depth, max)
    #iterate through width
    row(w-1, h, tr_func, max, [color|row])
  end


  #test function for demo
  def demo() do
    small(-2.6, 1.2, 1.2)
  end
  def small(x0, y0, xn) do
    width = 960
    height = 540
    depth = 64
    k = (xn - x0) / width
    image = Mandel.mandelbrot(width, height, x0, y0, k, depth)
    PPM.write("small.ppm", image)
  end

end
